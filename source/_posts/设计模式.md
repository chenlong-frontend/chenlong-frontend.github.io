---
title: 设计模式
author: 陈龙
date: 2021-01-04 22:21:16
tags: [设计模式]
categories: [设计模式]
---

本篇算是对极客上的 <<设计模式之美>> 看完之后的一个个人小总结。

### 设计模式与范式

#### 单例模式

一个类只允许创建一个对象，这个类就是单例类，这个模式就是单例模式。

对于系统中只应该保存一份的数据比较合适。

在实现的时候可以注意一下此单例类是初始就创建还是延时创建

示例如下
```js
class Logger {
    
}
class logger {
  static instance = new Logger()
  getInstance() {
    return this.instance;
  }
}
```

#### 工厂模式

当创建逻辑比较复杂的时候，可以考虑使用工厂模式，封装对象的创建过程。

- 当代码中存在 if-else 分支，动态的根据不同的类型创建不同的对象
- 单个对象本身创建比较复杂

就个人开发经验来说，在项目中遇到过根据传入参数，创建点线面箭头等对象的需求，使用了工厂模式

#### 建造者模式

当一个类初始化参数较复杂，存在众多参数和可选项，并且存在校验时，可以使用建造者模式，例如：

```js
class Builder {
    constructor(options){
      // ...
    }
    setName (name) {
      // ...
      return this
    }
    setMaxTotal (num) {
      // ...
      return this
    }
    build () {
      // ...
    }
}
```

其使用方式可能如下

```js
new Builder().setName("dbconnectionpool").setMaxTotal(16).build();
```

调用完`build` 之后算是一个完整的创建

#### 原型模式

`JavaScript` 的引入的类，便是基于原型的语法糖

#### 代理模式

代理模式，就是在不改变原始类的情况下，通过引入代理类来给原始类附加功能。示例如下

```js
class UserController {
  login(name) {
    // ...
  }
}

class UserControllerProxy {
  userController = null
  constructor(userController){
    this.userController = userController
  }
  login(name) {
    // ...
    this.userController.login(name)
    // ...
  }
}

// 使用
new UserControllerProxy(new UserController())
```

对于如果 `UserController` 的接口过于繁多，我们不想一个个的取重新覆写，可以通过 `proxy` 来返回我们不想覆写的接口

#### 桥接模式

在我的理解中，就是把多个分支执行组合，用作者的例子就是 JDBC驱动来查询各种数据库

#### 装饰器模式

在我的个人小库 [typescript-validate-param](https://github.com/chenlong-frontend/validate-param)中，通过装饰器模式，增强了原有函数，添加了参数校验的功能

#### 适配器模式

在我实际开发过程中，遇到过需要同时兼容两个版本`sdk`的需求，我是通过适配器模式模式来实现的，对外传入两个版本的sdk都可以了，内部通过适配，把接口做了一层转换，再暴露出去，以此达到同时兼容的目的

#### 门面模式

在我实际开发过程中，遇到过一个需求，有些内部二级模块下的方法需要挂在一级模块下暴露出去，例如

```js
// 原本挂在b下方法，需要通过c直接暴露
a.b.c() 
a.c()
```

这里通过属性拦截代理也可以实现，不过个人觉得门面模式更加清晰。另外门面还有拥有可以合并多模块接口调用的优势，非常适合

#### 组合模式

不常用模式。此模式并不是面向对象设计中的组合关系。以下引用作者原话说明一下

> 组合模式，将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且它利用树形结构的特点，递归地处理每个子树，依次简化代码实现。使用组合模式的前提在于，你的业务场景必须能够表示成树形结构。

#### 享元模式

不常用模式。其意图是复用对象，节省内存，前提是享元对象是不可变对象。其实现非常简单，通过工厂模式，用一个map存好即可。

与单例的区别在于，单例模式是为了保证对象的全局唯一，享元是为了实现对象复用，节省内存

#### 观察者模式

经典模式，自定义事件分发模式便是其中之一

#### 模板模式

在`js`中，我选择回调

#### 策略模式

简单来说，我觉得这个模式就是使用查表法来替换`if`和`switch`的分支判断

#### 职责链模式

引用原文

> 在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。

我觉着`vue3`中在调用了`createApp`后，感觉就是这种模式，每个函数把处理完的结果依次传给下一个

#### 状态模式

我觉着这个模式有点像 `vue` 中的 `vuex`和 `react` 中的 `redux`。

#### 访问者模式

代码可读性差，不建议使用。本质上就是将操作和对象解耦

#### 备忘录模式

捕捉一个对象的内部状态，并保存下来，例如我们实现一个编辑器，将用户的每一步操作后的结果都存到一个数组里，会导致一段时间后，对内存消耗会越来越大

所以我们需要全量备份和增量备份相结合，并且保持低频全量备份，高频增量备份。

#### 中介模式

这个模式在实际开发中有使用过，场景在于，我有很多小的模块，有些功能需求需要组合多个模块，而且需要一些必要的逻辑代码才能实现，这种情况下，便加入了一个中介者来实现，也就是一个上帝类，可以获取到所有模块的事件和方法，以此来实现对应的功能。

总结：由于最近一年的工作以`sdk`的的功能开发为主，这些设计模式多多少少都有了一些应用，有些是随着项目的不断壮大和复杂，自己想出来的一些优化方案，后来看了这篇课程之后，发现自己的有些实现很切合这其中的某一个设计模式，看完课程之后，又对项目进行了一些局部重构，更规范的来运用这些设计模式。

下面是总结的课程中的一些代码质量上的规范

### 快速改善代码质量的编程规范

#### 命名长度

对于一些默认的，大家熟知的词，采用缩写，作用域较小的变量，采用短一点的命名，相对类名这种的可以长一些

#### 通过上下文简化命名

一个例子就能明白

```js
User user = new User();
user.getName(); // 借助user对象这个上下文
```
#### 命名要可读，可搜索

不用是使用生僻词，可搜索体现在 `getXXX`、`selectXXX` 这种带有可搜索前缀的命名上

#### 命名接口

接口一般可以加前缀 `I`，表示 `Interface`，或者添加后缀`Impl`

#### 注释

注：这个我一般使用 vscode 的 `document.this`

#### 类、函数多大才合适

函数尽量不要超过一屏，类能做到内部接口清晰可寻

#### 一行代码多少最合适

尽量不要超过编辑器显示的宽度

#### 善用空行分割单元快、四格缩进还是两格缩进、大括号是否要另起一行

注：此处我一般使用编辑器自带格式化工具

#### 将代码分割成更小的单元快

只有在代码逻辑比较复杂的时候，才建议提炼类或者函数

#### 避免参数过多

函数参数多于 5个是，会影响到代码可读性，看是否能通过拆分多个函数来减少参数，或者将参数封装成对象

#### 勿用函数参数来控制逻辑

不要在函数中使用布尔类型的参数类控制内部逻辑

#### 函数设计要职责单一

要符合单一职责原则

#### 移除过深的嵌套层次

`if-else`、`switch-case`、`for` 的嵌套最好不要超过两层，一般有如下解决方法

- 去除多余的 `if` 或者 `else` 语句
- 使用编程语言提供的 `continue`、`break`、`return` 关键字，提前退出嵌套
- 调整执行顺序减少嵌套。
- 将部分嵌套封装成函数调用，以此来减少嵌套

#### 学会使用解释性变量

- 使用常量取代魔法数字，比如圆周率 `3.1415`，可以使用 `PI` 变量来承接一下
- 使用解释性变量来解释复杂表达式。例子如下

```js
if (date.after(SUMMER_START) && date.before(SUMMER_END)) {
  // ...
} else {
  // ...
}

// 引入解释性变量后逻辑更加清晰
const isSummer = date.after(SUMMER_START)&&date.before(SUMMER_END);
if (isSummer) {
  // ...
} else {
  // ...
} 
```